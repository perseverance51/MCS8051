C51 COMPILER V9.60.0.0   DS1302                                                            12/16/2021 17:10:55 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DS1302
OBJECT MODULE PLACED IN .\Objects\DS1302.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE DS1302.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\DS
                    -1302.lst) TABS(2) OBJECT(.\Objects\DS1302.obj)

line level    source

   1          //基于DS1302的日历时钟
   2          #include<reg51.h>     //包含单片机寄存器的头文件
   3          #include<intrins.h>   //包含_nop_()函数定义的头文件
   4          #include<DS1302.h> 
   5          /***********************************************************************
   6          以下是DS1302芯片的操作程序
   7          ************************************************************************/
   8          //unsigned char code digit[10]={"0123456789"};   //定义字符数组显示数字
   9          sbit DATA=P1^1;   //位定义1302芯片的接口，数据输出端定义在P1.1引脚
  10          sbit RST=P1^2;    //位定义1302芯片的接口，复位端口定义在P1.1引脚
  11          sbit SCLK=P1^0;   //位定义1302芯片的接口，时钟输出端口定义在P1.1引脚
  12          /*****************************************************
  13          函数功能：延时若干微秒
  14          入口参数：n
  15          ***************************************************/ 
  16          void delaynus(unsigned char n)
  17          {
  18   1       unsigned char i;
  19   1       for(i=0;i<n;i++)
  20   1            ;
  21   1      }
  22          /*****************************************************
  23          函数功能：向1302写一个字节数据
  24          入口参数：x
  25          ***************************************************/ 
  26          void Write1302(unsigned char dat)
  27          {
  28   1        unsigned char i; 
  29   1        SCLK=0;            //拉低SCLK，为脉冲上升沿写入数据做好准备
  30   1        delaynus(2);       //稍微等待，使硬件做好准备
  31   1        for(i=0;i<8;i++)      //连续写8个二进制位数据
  32   1          {
  33   2            DATA=dat&0x01;    //取出dat的第0位数据写入1302
  34   2          delaynus(2);       //稍微等待，使硬件做好准备
  35   2           SCLK=1;           //上升沿写入数据
  36   2           delaynus(2);      //稍微等待，使硬件做好准备
  37   2           SCLK=0;           //重新拉低SCLK，形成脉冲
  38   2           dat>>=1;          //将dat的各数据位右移1位，准备写入下一个数据位
  39   2          }
  40   1        
  41   1       }
  42          /*****************************************************
  43          函数功能：根据命令字，向1302写一个字节数据
  44          入口参数：Cmd，储存命令字；dat，储存待写的数据
  45          ***************************************************/ 
  46          void WriteSet1302(unsigned char Cmd,unsigned char dat)
  47           {
  48   1         RST=0;           //禁止数据传递
  49   1         SCLK=0;          //确保写数居前SCLK被拉低
  50   1        RST=1;           //启动数据传输
  51   1        delaynus(2);     //稍微等待，使硬件做好准备
  52   1        Write1302(Cmd);  //写入命令字
  53   1        Write1302(dat);  //写数据
  54   1        SCLK=1;          //将时钟电平置于已知状态
C51 COMPILER V9.60.0.0   DS1302                                                            12/16/2021 17:10:55 PAGE 2   

  55   1        RST=0;           //禁止数据传递
  56   1       }
  57          /*****************************************************
  58          函数功能：从1302读一个字节数据
  59          入口参数：x
  60          ***************************************************/ 
  61           unsigned char Read1302(void)
  62           {
  63   1         unsigned char i,dat;
  64   1        delaynus(2);       //稍微等待，使硬件做好准备
  65   1        for(i=0;i<8;i++)   //连续读8个二进制位数据
  66   1         {
  67   2           dat>>=1;       //将dat的各数据位右移1位，因为先读出的是字节的最低位
  68   2          if(DATA==1)    //如果读出的数据是1
  69   2           dat|=0x80;    //将1取出，写在dat的最高位
  70   2           SCLK=1;       //将SCLK置于高电平，为下降沿读出
  71   2           delaynus(2);  //稍微等待
  72   2           SCLK=0;       //拉低SCLK，形成脉冲下降沿
  73   2           delaynus(2);  //稍微等待
  74   2          }  
  75   1        return dat;        //将读出的数据返回
  76   1      }  
  77          /*****************************************************
  78          函数功能：根据命令字，从1302读取一个字节数据
  79          入口参数：Cmd
  80          ***************************************************/ 
  81          unsigned char  ReadSet1302(unsigned char Cmd)
  82           {
  83   1        unsigned char dat;
  84   1        RST=0;                 //拉低RST
  85   1        SCLK=0;                //确保写数居前SCLK被拉低
  86   1        RST=1;                 //启动数据传输
  87   1        Write1302(Cmd);       //写入命令字
  88   1        dat=Read1302();       //读出数据
  89   1        SCLK=1;              //将时钟电平置于已知状态
  90   1        RST=0;               //禁止数据传递
  91   1        return dat;          //将读出的数据返回
  92   1      }
  93          /*****************************************************
  94          函数功能： 1302进行初始化设置
  95          ***************************************************/ 
  96          void Init_DS1302(void)
  97          { 
  98   1         WriteSet1302(0x8E,0x00);                 //根据写状态寄存器命令字，写入不保护指令 
  99   1         WriteSet1302(0x80,((0/10)<<4|(0%10)));   //根据写秒寄存器命令字，写入秒的初始值
 100   1        WriteSet1302(0x82,((0/10)<<4|(0%10)));   //根据写分寄存器命令字，写入分的初始值
 101   1        WriteSet1302(0x84,((12/10)<<4|(12%10))); //根据写小时寄存器命令字，写入小时的初始值
 102   1        WriteSet1302(0x86,((16/10)<<4|(16%10))); //根据写日寄存器命令字，写入日的初始值
 103   1        WriteSet1302(0x88,((11/10)<<4|(11%10))); //根据写月寄存器命令字，写入月的初始值
 104   1        WriteSet1302(0x8c,((8/10)<<4|(8%10)));   //根据写小时寄存器命令字，写入小时的初始值
 105   1      }
 106          /*******************************************************************************
 107          
 108          函数功能：延时1ms
 109          (3j+2)*i=(3×33+2)×10=1010(微秒)，可以认为是1毫秒
 110          ***************************************************/
 111          //void delay1ms()
 112          //{
 113          //   unsigned char i,j; 
 114          //   for(i=0;i<10;i++)
 115          //    for(j=0;j<33;j++)
 116          //     ;     
C51 COMPILER V9.60.0.0   DS1302                                                            12/16/2021 17:10:55 PAGE 3   

 117          // }
 118          /*****************************************************
 119          函数功能：延时若干毫秒
 120          入口参数：n
 121          ***************************************************/
 122          // void delaynms(unsigned char n)
 123          // {
 124          //   unsigned char i;
 125          //  for(i=0;i<n;i++)
 126          //     delay1ms();
 127          // }
 128          
 129          
 130          
 131          
 132          /***************
 133          
 134           // Init_DS1302();       //将1302初始化,Proteus仿真时需要将初始注释掉，否则时间不会读取系统时间。
 135          unsigned char second,minute,hour,day,month,year;      //分别储存苗、分、小时，日，月，年
 136            unsigned char ReadValue;   //储存从1302读取的数据
 137              ReadValue = ReadSet1302(0x81);   //从秒寄存器读数据
 138               second=((ReadValue&0x70)>>4)*10 + (ReadValue&0x0F);//将读出数据转化
 139              DisplaySecond(second);          //显示秒
 140              ReadValue = ReadSet1302(0x83);  //从分寄存器读
 141               minute=((ReadValue&0x70)>>4)*10 + (ReadValue&0x0F); //将读出数据转化
 142              DisplayMinute(minute);         //显示分
 143               ReadValue = ReadSet1302(0x85);  //从分寄存器读
 144               hour=((ReadValue&0x70)>>4)*10 + (ReadValue&0x0F); //将读出数据转化
 145              DisplayHour(hour);               //显示小时
 146               ReadValue = ReadSet1302(0x87);  //从分寄存器读
 147               day=((ReadValue&0x70)>>4)*10 + (ReadValue&0x0F); //将读出数据转化
 148              DisplayDay(day);                //显示日
 149              ReadValue = ReadSet1302(0x89);  //从分寄存器读
 150               month=((ReadValue&0x70)>>4)*10 + (ReadValue&0x0F); //将读出数据转化
 151              DisplayMonth(month);            //显示月
 152              ReadValue = ReadSet1302(0x8d);  //从分寄存器读
 153               year=((ReadValue&0x70)>>4)*10 + (ReadValue&0x0F); //将读出数据转化
 154              DisplayYear(year);              //显示年
 155             }
 156          }
 157          
 158          *******/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    197    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
