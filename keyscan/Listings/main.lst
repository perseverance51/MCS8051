C51 COMPILER V9.60.0.0   MAIN                                                              06/15/2022 09:40:34 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* Main.c file generated by New Project wizard
   2           * 4X4矩阵按键显示0-F
   3           * Created:   周三 6月 15 2022
   4           * Processor: AT89C52
   5           * Compiler:  Keil for 8051
   6           */
   7          #include <reg52.h>
   8          sbit ADDR0 = P1^0;
   9          sbit ADDR1 = P1^1;
  10          sbit ADDR2 = P1^2;
  11          sbit ADDR3 = P1^3;
  12          sbit ENLED = P1^4;
  13          sbit KEY_IN_1 = P2^4;
  14          sbit KEY_IN_2 = P2^5;
  15          sbit KEY_IN_3 = P2^6;
  16          sbit KEY_IN_4 = P2^7;
  17          sbit KEY_OUT_1 = P2^3;
  18          sbit KEY_OUT_2 = P2^2;
  19          sbit KEY_OUT_3 = P2^1;
  20          sbit KEY_OUT_4 = P2^0;
  21          unsigned char code LedChar[] = { //数码管显示字符转换表
  22           0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
  23           0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E
  24          };
  25          unsigned char KeySta[4][4] = { //全部矩阵按键的当前状态
  26           {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}
  27          };
  28          void main()
  29          {
  30   1       unsigned char i, j;
  31   1       unsigned char backup[4][4] = { //按键值备份，保存前一次的值
  32   1       {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}
  33   1       };
  34   1      EA = 1; //使能总中断
  35   1       ENLED = 0; //选择数码管 DS1 进行显示
  36   1       ADDR3 = 1;
  37   1       ADDR2 = 0;
  38   1       ADDR1 = 0;
  39   1       ADDR0 = 0;
  40   1       TMOD = 0x01; //设置 T0 为模式 1
  41   1       TH0 = 0xFC; //为 T0 赋初值 0xFC67，定时 1ms
  42   1       TL0 = 0x67;
  43   1       ET0 = 1; //使能 T0 中断
  44   1       TR0 = 1; //启动 T0
  45   1       P0 = LedChar[0]; //默认显示 0
  46   1       while (1)
  47   1       {
  48   2       for (i=0; i<4; i++) //循环检测 4*4 的矩阵按键
  49   2       {
  50   3       for (j=0; j<4; j++)
  51   3       {
  52   4       if (backup[i][j] != KeySta[i][j]) //检测按键动作
  53   4       {
  54   5       if (backup[i][j] != 0) //按键按下时执行动作
C51 COMPILER V9.60.0.0   MAIN                                                              06/15/2022 09:40:34 PAGE 2   

  55   5       {
  56   6       P0 = LedChar[i*4+j]; //将编号显示到数码管
  57   6       }
  58   5       backup[i][j] = KeySta[i][j]; //更新前一次的备份值
  59   5       }
  60   4       }
  61   3       }
  62   2       }
  63   1      }
  64          /* T0 中断服务函数，扫描矩阵按键状态并消抖 */
  65          void InterruptTimer0() interrupt 1
  66          {
  67   1       unsigned char i;
  68   1       static unsigned char keyout = 0; //矩阵按键扫描输出索引
  69   1       static unsigned char keybuf[4][4] = { //矩阵按键扫描缓冲区
  70   1       {0xFF, 0xFF, 0xFF, 0xFF}, {0xFF, 0xFF, 0xFF, 0xFF},
  71   1       {0xFF, 0xFF, 0xFF, 0xFF}, {0xFF, 0xFF, 0xFF, 0xFF}
  72   1       };
  73   1       
  74   1       TH0 = 0xFC; //重新加载初值
  75   1       TL0 = 0x67;
  76   1      //将一行的 4 个按键值移入缓冲区
  77   1       keybuf[keyout][0] = (keybuf[keyout][0] << 1) | KEY_IN_1;
  78   1       keybuf[keyout][1] = (keybuf[keyout][1] << 1) | KEY_IN_2;
  79   1       keybuf[keyout][2] = (keybuf[keyout][2] << 1) | KEY_IN_3;
  80   1       keybuf[keyout][3] = (keybuf[keyout][3] << 1) | KEY_IN_4;
  81   1       //消抖后更新按键状态
  82   1       for (i=0; i<4; i++) //每行 4 个按键，所以循环 4 次
  83   1       {
  84   2       if ((keybuf[keyout][i] & 0x0F) == 0x00)
  85   2       { //连续 4 次扫描值为 0，即 4*4ms 内都是按下状态时，可认为按键已稳定的按下
  86   3       KeySta[keyout][i] = 0;
  87   3       }
  88   2       else if ((keybuf[keyout][i] & 0x0F) == 0x0F)
  89   2       { //连续 4 次扫描值为 1，即 4*4ms 内都是弹起状态时，可认为按键已稳定的弹起
  90   3       KeySta[keyout][i] = 1;
  91   3       }
  92   2       }
  93   1       //执行下一次的扫描输出
  94   1       keyout++; //输出索引递增
  95   1       keyout = keyout & 0x03; //索引值加到 4 即归零
  96   1       switch (keyout) //根据索引，释放当前输出引脚，拉低下次的输出引脚
  97   1       {
  98   2       case 0: KEY_OUT_4 = 1; KEY_OUT_1 = 0; break;
  99   2       case 1: KEY_OUT_1 = 1; KEY_OUT_2 = 0; break;
 100   2       case 2: KEY_OUT_2 = 1; KEY_OUT_3 = 0; break;
 101   2       case 3: KEY_OUT_3 = 1; KEY_OUT_4 = 0; break;
 102   2       default: break;
 103   2       }
 104   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    410    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     33      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
