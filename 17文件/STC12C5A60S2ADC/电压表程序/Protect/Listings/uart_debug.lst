C51 COMPILER V9.60.0.0   UART_DEBUG                                                        04/10/2022 12:25:54 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE UART_DEBUG
OBJECT MODULE PLACED IN ..\output\uart_debug.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\source\uart_debug.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\uart_debug.lst) TABS(2) OBJECT(..\output\uart_debug.obj)

line level    source

   1          /**************** *************
   2           ★★★★★★★★★★★★★★★★★★★★★★★★
   3          
   4            ★★★★★★★★★★★★★★★★★★★★★★★★*/
   5          #include "uart_debug.H"
   6          #include <STC12C5A60S2.H>
   7          #include <string.h>   
   8          /******************************************************************
   9           - 功能描述：将一个32位长整型变量dat转为字符串，比如把1234转为"1234"
  10           - 参数说明：dat:待转的long型的变量
  11                       str:指向字符数组的指针，转换后的字节串放在其中           
  12           ******************************************************************/ 
  13          void Long_Str(unsigned long dat,char *str) 
  14          {
  15   1        unsigned char temp[11];  // 长整数最大值4294967295，转ASCII码后占用10字节   
  16   1        unsigned char i=0,j=0;    
  17   1        while(dat)         // 数值转ASCII码，字节在数组中反向排列
  18   1        {
  19   2          temp[i]=dat%10+0x30;
  20   2          i++;
  21   2          dat/=10;
  22   2        }
  23   1        j=i;
  24   1        for(i=0;i<j;i++)     // 数组交换先后顺序，正向排列
  25   1        {
  26   2          str[i]=temp[j-i-1];  // C语言中数组下标固定从0开始
  27   2        }
  28   1        if(!i) {str[i++]='0';}   // 函数参数dat=0处理
  29   1        str[i]=0;        // 由于要使用KEIL自带的字符串处理函数处理，必须有结束标记。
  30   1      }
  31          /******************************************************************
  32           - 功能描述：将一个字符串转为32位长整型变量，比如"1234"转为1234
  33           - 参数说明：str:指向待转换的字符串           
  34           - 返回说明：转换后的数值                          
  35           ******************************************** **********************/ 
  36          /*
  37          unsigned long Str_Long(char *str) 
  38          {
  39             unsigned long temp=0;
  40             unsigned long fact=1;
  41             unsigned char len=strlen(str); // <string.h>头文件包含strlen()函数 
  42             unsigned char i;   // strlen()函数计算的字符串长度不包含最后一个空字符(值0)
  43             for(i=len;i>0;i--)                                
  44             {
  45              temp+=((str[i-1]-0x30)*fact);  // 数组下标从0开始
  46              fact*=10;
  47             }
  48             return temp;
  49          } */  
  50          
  51          /**************************************************************************
  52           - 功能描述：STC15单片机串口1初始化,使用T1方式2自重载方式做波特率发生器 
  53           **************************************************************************/
  54          void UART_init(void)
C51 COMPILER V9.60.0.0   UART_DEBUG                                                        04/10/2022 12:25:54 PAGE 2   

  55          {     
  56   1        // 下面代码设置定时器1
  57   1        TMOD |= 0x20; // 0010 0000 定时器1工作于方式2（8位自动重装方式）
  58   1        TH1  = 0xFd;  // 波特率：9600 /11.0592MHZ
  59   1        TL1  = 0xFd;  // 波特率：9600 /11.0592MHZ
  60   1        TR1  = 1;
  61   1        // 下面代码设置定串口
  62   1        AUXR = 0x00;             // 很关键，使用定时器1作为波特率发生器，S1ST2=0
  63   1        SCON = 0x50;  // 01010 0000 SM0.SM1=01(最普遍的8位通信）,REN=1（允许接受）
  64   1        // 下面代码设置中断
  65   1        ES   = 1;   // 关键：开启了中断就必须编写相应的中断函数，哪怕是中断空函数，
  66   1                        // 但必须有,否则程序进入中断入口地址后（这里是0023H)不能跳出，必然出错
  67   1        EA   = 1;
  68   1      }  
  69          
  70          /**************************************************************************
  71           -功能描述：STC15单片机的串口发送字节的函数
  72            参数说明：dat:要发送的一个字节   
  73          **************************************************************************/
  74          void UART_Send_Byte(unsigned char dat)
  75          {
  76   1        ES=0;    // 使用查询发送结束方式，禁止中断干预
  77   1        SBUF = dat;
  78   1        while(!TI);     
  79   1        TI=0;  //此句可以不要，不影响后面数据的发送，只供代码查询数据是否发送完成
  80   1        ES=1;
  81   1      } 
  82          /**************************************************************************
  83           - 功能描述：STC15单片机的串口发送0d 0a ，即回车换行 
  84           - 注：此函数就是发送0d 0a这两个字节，在"串口助手"上会有回车换行的效果
  85           **************************************************************************/  
  86          void UART_Send_Enter()
  87          {
  88   1        UART_Send_Byte(0x0d); // 转义字符常量\r，ASCII码值（10进制）=13，光标移到本行行首
  89   1        UART_Send_Byte(0x0a); // 转义字符常量\n，ASCII码值（10进制）=10，光标移到下行行首
  90   1      }
  91          
  92          /*
  93          void UART_Send_Str(char *buf)
  94          {
  95            while (*buf != '\0')   //说明：C语言字符串数组结尾必然有一个"\0"字符，在内存中数值为0
  96            {
  97              UART_send_byte(*buf++);  //说明：* 和 ++优先级相同，结合性从右到左，但是++运
  98            }              //算符有个特性就是先让变量参与运算，后进行加1操作
  99          }  */
 100          
 101          /**************************************************************************
 102           - 功能描述：51单片机的串口发送字符串  
 103           - 参数说明：s:指向字符串的指针   
 104           - 注：如果在字符串中有'\n'，则会发送一个回车换行
 105           **************************************************************************/
 106          void UART_Send_Str(char *s)
 107          {
 108   1        unsigned int i;   
 109   1        unsigned int len=strlen(s)-1;   // 最后一个字符单独处理
 110   1        for(i=0;i<len;i++) 
 111   1          UART_Send_Byte(s[i]);   //  while (*buf != '\0')  UART_Send_Byte(*s++);
 112   1        if(s[i]=='\n')           
 113   1        {
 114   2          UART_Send_Enter();
 115   2        }
 116   1        else
C51 COMPILER V9.60.0.0   UART_DEBUG                                                        04/10/2022 12:25:54 PAGE 3   

 117   1        {
 118   2          UART_Send_Byte(s[i]); // 普通字符正常发送
 119   2        }
 120   1      }
 121          /**************************************************************************
 122           - 功能描述：51单片机的串口发送数值
 123           - 参数说明：dat:要发送的数值(长整数)
 124           - 注：函数中会将数值转为相应的字符串，发送出去。比如 4567 转为 "4567" 
 125           **************************************************************************/
 126          void UART_Send_Num(unsigned long dat)
 127          {
 128   1        unsigned char temp[11];   // 长整数最大值4294967295，转ASCII码后占用10字节
 129   1            //  由于后面程序要使用strlen()库函数计算长度，需增加1个字节存放结束符0
 130   1        Long_Str(dat,temp);   
 131   1        UART_Send_Str(temp);
 132   1        UART_Send_Enter();          // 发送回车 
 133   1      }
 134          /**************************************************************************
 135           - 功能描述：51单片机的串口发送调试信息（字符串+数值）    
 136           - 参数说明：inf:指向提示信息字符串的指针
 137                       dat:一个数值，前面的提示信息就是在说明这个数值的意义
 138           **************************************************************************/
 139          void UART_Send_StrNum(char *inf,unsigned long dat)
 140          {
 141   1        UART_Send_Str(inf);
 142   1        UART_Send_Num(dat); 
 143   1      } 
 144          
 145          /**************************************************************************
 146           - 功能描述：16进制转ASCII码函数
 147           - 隶属模块：STC51串口操作
 148           - 函数属性：内部，供本模块内部调用  
 149           **************************************************************************/
 150          unsigned char Hex_ASCII(unsigned int hex,char *str)
 151          {
 152   1        unsigned char temp=0;
 153   1        
 154   1        temp=((hex&0xf000)>>12);    // 4位1表示范围0_9_A_F
 155   1        str[0]=(temp>=10)?(temp-10+'A'):(temp+0x30);
 156   1          // 0_9的ASCII码是0_9+ 0x30，
 157   1            // A_F的ASCII码: A代表数值10，A的ASCII码是65，因此数值+55=ASCII
 158   1          // 因此算式(temp-10+'A')=(temp-10+65)=(temp+55)
 159   1          // 分析依据：ASCII码表
 160   1        temp=((hex&0x0f00)>>8);
 161   1        str[1]=(temp>=10)?(temp-10+'A'):(temp+0x30);
 162   1        
 163   1        temp=((hex&0x00f0)>>4);
 164   1        str[2]=(temp>=10)?(temp-10+'A'):(temp+0x30);
 165   1        
 166   1        temp=((hex&0x000f)>>0);
 167   1        str[3]=(temp>=10)?(temp-10+'A'):(temp+0x30);
 168   1        
 169   1        str[4]=0;     // 由于要使用KEIL自带的字符串处理函数处理，必须有结束标记。 
 170   1        
 171   1        return 0;
 172   1      } 
 173          
 174          /**************************************************************************
 175           - 功能描述：51单片机的串口输出ASCII码函数（接收端按字符形式接收则显示为HEX格式 ）
 176           - 隶属模块：STC51串口操作
 177           - 函数属性：外部，供用户使用  
 178           **************************************************************************/
C51 COMPILER V9.60.0.0   UART_DEBUG                                                        04/10/2022 12:25:54 PAGE 4   

 179          void UART_Send_Hex(unsigned int hex)
 180          {
 181   1        unsigned char temp[11];
 182   1        Hex_ASCII(hex,temp);
 183   1        UART_Send_Str(temp);
 184   1        UART_Send_Enter();          // 发送回车
 185   1      }
 186          
 187          /**************************************************************************
 188           - 功能描述：51单片机的串口发送调试信息（二进制数据显示）   
 189           - 参数说明：dat:需要按2进制形式显示变量
 190           **************************************************************************/
 191          void UART_Send_binary(unsigned char dat)
 192          {
 193   1        unsigned char i;
 194   1        unsigned char a[17];
 195   1        for(i=0;i<8;i++)
 196   1        {
 197   2          a[i]=((dat<<i)&0x80)?'1':'0';
 198   2        }
 199   1        a[i]=0;
 200   1        for(i=0;i<strlen(a);i++)
 201   1        {
 202   2          UART_Send_Byte(a[i]);
 203   2          UART_Send_Byte(' ');
 204   2        }
 205   1        UART_Send_Enter();          // 发送回车
 206   1      }
 207          /**************************************************************************
 208           - 功能描述：51单片机的串口1中断处理函数  
 209           **************************************************************************/
 210          void UART1_ISR (void) interrupt 4  // 串行口1中断函数  
 211          { ; }
 212          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    588    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      71
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
