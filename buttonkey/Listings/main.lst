C51 COMPILER V9.60.0.0   MAIN                                                              06/15/2022 09:06:43 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* Main.c file generated by New Project wizard
   2           *简易加法计算器
   3           * Created:   周二 6月 14 2022
   4           * Processor: AT89C52
   5           * Compiler:  Keil for 8051
   6           */
   7          
   8          #include <reg52.h>
   9           
  10          sbit ADDR0 = P1^0;
  11          sbit ADDR1 = P1^1;
  12          sbit ADDR2 = P1^2;
  13          sbit ADDR3 = P1^3;
  14          sbit ENLED = P1^4;
  15          sbit KEY_IN_1 = P2^4;
  16          sbit KEY_IN_2 = P2^5;
  17          sbit KEY_IN_3 = P2^6;
  18          sbit KEY_IN_4 = P2^7;
  19          sbit KEY_OUT_1 = P2^3;
  20          sbit KEY_OUT_2 = P2^2;
  21          sbit KEY_OUT_3 = P2^1;
  22          sbit KEY_OUT_4 = P2^0;
  23          unsigned char code LedChar[] = {            //数码管显示字符转换表
  24          0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
  25          0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E
  26          };
  27          unsigned char LedBuff[6]={0xff,0xff,0xff,0xff,0xff,0xff}; //数码管显示缓冲区 
  28          unsigned char code KeyCodeMap[4][4] = { //矩阵按键编号到标准键盘键码的映射表
  29          { 0x31, 0x32, 0x33, 0x26 }, //数字键 1、数字键 2、数字键 3、向上键
  30          { 0x34, 0x35, 0x36, 0x25 }, //数字键 4、数字键 5、数字键 6、向左键
  31          { 0x37, 0x38, 0x39, 0x28 }, //数字键 7、数字键 8、数字键 9、向下键
  32          { 0x30, 0x1B, 0x0D, 0x27 } //数字键 0、ESC 键、 回车键、 向右键
  33          };        
  34          unsigned char KeySta[4][4] = {              //全部矩阵按键的当前状态
  35          {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}
  36          };
  37           
  38           
  39          unsigned char THR0,TLR0;
  40          void KeyDriver();
  41          void ConfigTimer(unsigned long ms);
  42          void main()
  43          {
  44   1        EA = 1;     //使能总中断
  45   1        ENLED = 0;
  46   1        ADDR3 = 1;
  47   1        ConfigTimer(1);  //计算定时1ms，需要赋的初值，存在在 THR0,TLR0中
  48   1        TMOD = TMOD & 0xF0;
  49   1        TMOD = TMOD | 0x01; //设置定时器模式1 ,不影响高四位
  50   1        TH0 = THR0;  //定时器赋初值
  51   1        TL0 = TLR0;
  52   1        ET0= 1;   //使能T0中断
  53   1        TR0 = 1;    //启动定时器T0
  54   1        LedBuff[0] = LedChar[0];   //数码管默认显示0
C51 COMPILER V9.60.0.0   MAIN                                                              06/15/2022 09:06:43 PAGE 2   

  55   1        while(1)
  56   1        {
  57   2           KeyDriver();
  58   2        }
  59   1      }
  60          void ConfigTimer(unsigned long ms)
  61          {
  62   1        unsigned long temp;
  63   1        temp = 65536 - ms*11059200/1000/12; //ms最大定时71ms
  64   1        THR0 = (unsigned char)(temp>>8);      //取计数值高八位 ，计数值不会超过65535，最多占用16位。
  65   1        TLR0 = (char)temp;          //取计数值低八位         
  66   1      }
  67          void ShowNumber(unsigned long num)
  68          {
  69   1         signed char i;
  70   1         unsigned char buf[6];   //将num六位数字按顺序放入buf数组中
  71   1         for(i=0;i<=5;i++)
  72   1         {
  73   2          buf[i]=num%10;
  74   2          num = num/10;
  75   2         }
  76   1         for(i=5;i>=1;i--)       //从高位到低位依次扫描，直到某一位不为0
  77   1         {
  78   2          if(buf[i]==0)
  79   2          {
  80   3            LedBuff[i]=0xff;     //如果高位为0，则关闭此对应数码管显示，否则跳出，保留buf[]中不为0的下角标在i中
  81   3          }
  82   2          else
  83   2          {
  84   3            break;
  85   3          }
  86   2         }
  87   1         for(;i>=0;i--)
  88   1         {
  89   2          LedBuff[i]=LedChar[buf[i]];    //将各位数字取出，转换成数码管显示字符放入公有数组变量LedBuff[6]中
  90   2         }
  91   1      }
  92          void KeyAction(unsigned char keycode)
  93          {
  94   1        static unsigned long result = 0;
  95   1        static unsigned long addend = 0;
  96   1        if((keycode>=0x30)&&(keycode<=0x39))    //输入的是数字
  97   1        {
  98   2          addend = (addend*10)+(keycode-0x30);   //将原有数字顶上去
  99   2          ShowNumber(addend);
 100   2        }
 101   1        else if(keycode == 0x26)     //上键，执行加法操作
 102   1        {
 103   2          result += addend;    //将上一个数字addend存在result中，清空addend，等待下一次数字
 104   2          addend = 0;
 105   2          ShowNumber(result);
 106   2        }
 107   1        else if(keycode == 0x0D)    //回车键，作用和上键等同
 108   1        {
 109   2          result += addend;    //将上一个数字addend存在result中，清空addend，等待下一次数字
 110   2          addend = 0;
 111   2          ShowNumber(result); 
 112   2        }
 113   1        else if(keycode == 0x1B)         //esc键，清零
 114   1        {
 115   2          addend = 0;
 116   2          result = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              06/15/2022 09:06:43 PAGE 3   

 117   2          ShowNumber(addend);
 118   2        }
 119   1      }
 120          void KeyDriver()  
 121          {
 122   1        unsigned char i,j;
 123   1        static unsigned char backup[4][4]={           //一定定义成静态，否则bug
 124   1        {1,1,1,1}, {1,1,1,1},{1,1,1,1},{1,1,1,1}
 125   1        };
 126   1         for(i=0;i<4;i++)
 127   1        {
 128   2          for(j=0;j<4;j++)
 129   2          {
 130   3            if(KeySta[i][j]!=backup[i][j])  //当前按键状态和之前按键状态不一致，证明按键已经按下或者抬起
 131   3            {
 132   4              if(KeySta[i][j]==0)          //如果当前按键状态为0，说明按键按下；在此我们只对按键按下动作响应
 133   4              {
 134   5                KeyAction(KeyCodeMap[i][j]);  //将对应的按键转换成标准键盘码传入KeyAction中，根据传入的键盘码执行相应
             -动作
 135   5              }
 136   4              backup[i][j]=KeySta[i][j];   //保存当前按键状态
 137   4            }
 138   3          }
 139   2        }
 140   1      }
 141           
 142           
 143           
 144          void LedScan()
 145          {
 146   1        static unsigned char i = 0;
 147   1        P0=0xff;
 148   1        switch(i)
 149   1        {
 150   2          case 0: ADDR2=0;ADDR1=0;ADDR0=0;P0=LedBuff[i];i++;break;
 151   2          case 1: ADDR2=0;ADDR1=0;ADDR0=1;P0=LedBuff[i];i++;break;
 152   2          case 2: ADDR2=0;ADDR1=1;ADDR0=0;P0=LedBuff[i];i++;break;
 153   2          case 3: ADDR2=0;ADDR1=1;ADDR0=1;P0=LedBuff[i];i++;break;
 154   2          case 4: ADDR2=1;ADDR1=0;ADDR0=0;P0=LedBuff[i];i++;break;
 155   2          case 5: ADDR2=1;ADDR1=0;ADDR0=1;P0=LedBuff[i];i=0;break;
 156   2          default:break;
 157   2        }
 158   1      }
 159          void KeyScan()
 160          {
 161   1        static unsigned char keyout = 0;
 162   1        unsigned char i;
 163   1        static unsigned char keybuf[4][4]={
 164   1        {0xff,0xff,0xff,0xff},{0xff,0xff,0xff,0xff},{0xff,0xff,0xff,0xff},{0xff,0xff,0xff,0xff}
 165   1        };
 166   1        keybuf[keyout][0] = (keybuf[keyout][0]<<1)| KEY_IN_1;
 167   1        keybuf[keyout][1] = (keybuf[keyout][1]<<1)| KEY_IN_2;
 168   1        keybuf[keyout][2] = (keybuf[keyout][2]<<1)| KEY_IN_3;
 169   1        keybuf[keyout][3] = (keybuf[keyout][3]<<1)| KEY_IN_4;
 170   1        for(i=0;i<=3;i++)
 171   1        {
 172   2          if((keybuf[keyout][i]&0x0f)==0x00)
 173   2          {
 174   3            KeySta[keyout][i]=0;
 175   3          }
 176   2          else if((keybuf[keyout][i]&0x0f)==0x0f)
 177   2          {
C51 COMPILER V9.60.0.0   MAIN                                                              06/15/2022 09:06:43 PAGE 4   

 178   3            KeySta[keyout][i]=1;
 179   3          }
 180   2          else
 181   2          {}
 182   2        }
 183   1        keyout++;
 184   1        if(keyout>=4)
 185   1        {keyout=0;}
 186   1        switch(keyout)               //扫描下一行
 187   1        {
 188   2          case 0: KEY_OUT_4=1;KEY_OUT_1=0;break;
 189   2          case 1: KEY_OUT_1=1;KEY_OUT_2=0;break;
 190   2          case 2: KEY_OUT_2=1;KEY_OUT_3=0;break;
 191   2          case 3: KEY_OUT_3=1;KEY_OUT_4=0;break;
 192   2          default:break;
 193   2        }   
 194   1      }
 195          void  InterruptTimer0() interrupt 1       
 196          {
 197   1         TH0=THR0;
 198   1         TL0=TLR0;
 199   1         LedScan();
 200   1         KeyScan();
 201   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    996    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     66      22
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
